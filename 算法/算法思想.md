<!--
 * @Description:
 * @Date: 2022-05-28 10:25:38
 * @Author: mason
-->

# 数据结构本质

数据结构细看只有`数组`和`链表`，其他的队列，栈，树，图等都是基于这两个扩展的

# 操作

操作的本质只有两种，`迭代`和`递归`，迭代是线性，递归是非线性

## 数组

数组遍历就是迭代

```js
function traverse(arr){
  for(let i = 0; i < arr.length; i++){
    ...
  }
}
```

## 链表

链表遍历可以是迭代也可以是递归

```js
function traverse(head){
  for(let i = head; i !== null, i = i.next){
    ...
  }
}

function traverse(head){
  // 先序遍历
  traverse(head.next)
  // 后序遍历
}

```

## 二叉树

二叉树结构就是链表扩展出来的， 所以**涉及到递归的问题都是树的问题。**

```js
function traverse(tree) {
  // 先序遍历
  traverse(tree.left);
  // 中序遍历
  traverse(tree.right);
  // 后序遍历
}
```

## n 叉树

```js
function traverse(tree){
  for(tree.children){
    traverse(tree.child)
  }
}
```

# 技巧

## 双指针

### 快慢指针

使用： 原地修改数组（去重，移除元素）

### 左右指针

使用： 二分查找

#### 滑动窗口算法

`lfet`指针在后， `right`指针在前

```js
function slidingWindow(s, t){
  let left = 0, right = 0, valid = 0
  while(right < s.length){
    let c = s[right]
    // 右移增大窗口
    right++
    // 进行窗口内数据的更新
    ...
    while("开始缩小窗口"){
      d = s[left]
      // 左移减小窗口
      left++
      // 进行窗口内数据的更新
      ...
    }
  }
}
```

# 解题技巧

## 回文：从中心向两端扩散的双指针

找回文串的难点在于，回文串的的长度可能是奇数也可能是偶数，解决该问题的核心是**从中心向两端扩散的双指针技巧**。

### 查找最长回文子串

```js
function longestPalindrome(s: string) {
  let res = "";
  for (let i = 0; i < s.length; i++) {
    // 以 s[i] 为中心的最长回文子串
    let s1 = palindrome(s, i, i);
    // 以 s[i] 和 s[i+1] 为中心的最长回文子串
    let s2 = palindrome(s, i, i + 1);
    // res = longest(res, s1, s2)
    res = res.length > s1.length ? res : s1;
    res = res.length > s2.length ? res : s2;
  }

  // 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串
  function palindrome(s, l, r) {
    // 防止索引越界
    while (l >= 0 && r < s.length && s.charAt(l) == s.charAt(r)) {
      // 双指针，向两边展开
      l--;
      r++;
    }
    // 返回以 s[l] 和 s[r] 为中心的最长回文串
    return s.substring(l + 1, r);
  }

  return res;
}
```

## 区间内的元素和： 前缀和

**前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。**

## 差分数组：主要适用场景是频繁对原始数组的某个区间的元素进行增减
