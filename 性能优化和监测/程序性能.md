# Web Worker

把你的程序分为两个部分：一部分运行在主 UI 线程下，另外一部分运行在另一个完全独立的线程中
这样的架构可能引出的问题：

1. 需要了解在独立的线程运行是否意味值它可以并行运行。
2. 这两个部分能否共享作用域和资源？如果能的话，你会想要知道它们将如何实现通信。

Web Worker 是浏览器（即宿主环境）的功能，JavaScript 当前并没有任何支持多线程执行的功能。

从 JavaScript 主程序中，可以这样实例化一个 Worker

```js
var w1 = new Worker("http://xxx/xxx.js");
```

这个 url 应该指向一个 js 文件的位置。这个文件将被加载到一个 worker 中，然后浏览器启动一个独立的线程，让这个文件在这个线程中作为独立的程序运行。

## Worker 环境

在 Worker 内部是无法访问主程序的任何资源的。这意味着你不能访问它的任何全局变量，也不能访问页面的 DOM 或者其他资源，这是一个完全独立的线程！

可以通过`importScripts('xxx.js')`来向 Worker 加载额外的 JS 脚本，这些脚本加载是同步的。

Web Worker 通常应用场景：

1. 处理密集型数学计算
2. 大数据集排序
3. 数据处理（压缩，音频分析，图像处理等）
4. 高流量网络通信

## 数据传递

上述的应用场景有个共同点就是需在线程之间通过事件机制传递大量的信息，可能是双向的。

## 共享 Worker

# SIMD

单指令多数据（SIMD）是一种数据并行的方式，与 Web Worker 的任务并行相对，这里的重点不再是把程序逻辑分成并行的块，而是并行处理数据的多个位。

# 性能测试与调优

## 性能测试

```js
var start = new Date().getTime(); //或者Date.now()
var end = new Date().getTime();

console.log("duration:", end - start);
```

这是一种常用的方案，但是有些问题，可信度低，精度低。

## Benchmark.js

## 环境为王

引擎优化

## 尾递归优化

```js
function foo(x) {
  return x;
}

function bar(y) {
  return foo(y + 1); //尾调用
}

function baz() {
  return 1 + bar(40); //非尾调用
}

baz();
```

调用一个新的函数需要额外的一块预留内存来管理调用栈，称为栈帧。所以前面的代码一般会为上面每个函数保留一个栈帧。
然鹅，如果支持 TCO 的引擎能够意识到 foo(y+1)调用位于尾部，这意味着 bar()基本完成了，那么在调用 foo()时，它就不需要创建一个新的栈帧，而是可以重用已有的 bar()的栈帧，这样不仅速度更快，也更节省内存。

## 前端性能优化你会怎么做？

减少回流重绘
缩小代码体积，例如：Tree-shaking、代码压缩、代码分割、Scope-hoisting 等
减少请求数，例如：雪碧图、基础库打成一个包
并发请求，使用 cdn，突破浏览器对同一域名的 TCP 连接数限制，或者使用 http2
运行时加载，例如：图片懒加载，组件动态 import
缓存，例如：http 缓存，dll 等
