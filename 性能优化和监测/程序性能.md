# Web Worker
把你的程序分为两个部分：一部分运行在主UI线程下，另外一部分运行在另一个完全独立的线程中
这样的架构可能引出的问题：
1. 需要了解在独立的线程运行是否意味值它可以并行运行。
2. 这两个部分能否共享作用域和资源？如果能的话，你会想要知道它们将如何实现通信。

Web Worker是浏览器（即宿主环境）的功能，JavaScript当前并没有任何支持多线程执行的功能。

从JavaScript主程序中，可以这样实例化一个Worker
```js
var w1 = new Worker("http://xxx/xxx.js")
```
这个url应该指向一个js文件的位置。这个文件将被加载到一个worker中，然后浏览器启动一个独立的线程，让这个文件在这个线程中作为独立的程序运行。

## Worker环境
在Worker内部是无法访问主程序的任何资源的。这意味着你不能访问它的任何全局变量，也不能访问页面的DOM或者其他资源，这是一个完全独立的线程！

可以通过`importScripts('xxx.js')`来向Worker加载额外的JS脚本，这些脚本加载是同步的。

Web Worker通常应用场景：
1. 处理密集型数学计算
2. 大数据集排序
3. 数据处理（压缩，音频分析，图像处理等）
4. 高流量网络通信

## 数据传递

上述的应用场景有个共同点就是需在线程之间通过事件机制传递大量的信息，可能是双向的。

## 共享Worker



# SIMD
单指令多数据（SIMD）是一种数据并行的方式，与Web Worker的任务并行相对，这里的重点不再是把程序逻辑分成并行的块，而是并行处理数据的多个位。




# 性能测试与调优

## 性能测试
```js
var start = (new Date()).getTime()   //或者Date.now()
var end = (new Date()).getTime()

console.log("duration:", end - start)
```

这是一种常用的方案，但是有些问题，可信度低，精度低。

## Benchmark.js

## 环境为王
引擎优化

## 尾递归优化
```js
function foo(x){
  return x
}

function bar(y){
  return foo(y+1)     //尾调用
}

function baz(){
  return 1 + bar(40)   //非尾调用
}

baz()
```

调用一个新的函数需要额外的一块预留内存来管理调用栈，称为栈帧。所以前面的代码一般会为上面每个函数保留一个栈帧。
然鹅，如果支持TCO的引擎能够意识到foo(y+1)调用位于尾部，这意味着bar()基本完成了，那么在调用foo()时，它就不需要创建一个新的栈帧，而是可以重用已有的bar()的栈帧，这样不仅速度更快，也更节省内存。










