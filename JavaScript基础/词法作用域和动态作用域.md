# 作用域
作用域是指程序源代码中定义变量的区域。
作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。
JavaScript采用**词法作用域**，也就是静态作用域。

# 静态作用域和动态作用域
**静态作用域在函数定义的时候就决定了，而动态作用域是在函数调用的时候才决定的。**

```js
var v = 1;
function foo(){
  console.log(v)
}
function bar(){
  var v = 2;
  foo()
}
bar()
```
在上面的小例子中，如果js是静态作用域会输出1，如果是动态作用域会输出2.因为，
静态作用域执行过程：foo从内部找v，找不到会根据**书写位置**查找上一层代码，找到1；
动态作用域执行过程：foo从内部找v，找不到会根据**调用函数的作用域**查找，即从bar内部找到了2

小测试：
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();   //???

var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();   //???
```

答案： 都是local scope
原因： 因为JavaScript采用词法作用域，函数的作用域基于函数创建的位置。
JavaScript函数的执行用到了**作用域链**，这个作用域链在函数定义的时候创建的。嵌套的函数f()定义在这个作用域链里，其中的变量scope一定是局部变量，不管何时何地执行f(),折中绑定在执行f()时依然有效。


# 理解作用域
引擎： 从头到尾负责整个JavaScript程序的编译及执行过程。
编译器： 负责语法分析及代码生成
作用域： 负责收集并维护由所有声明的标识符（变量）组成的一系列查询，确定当前执行代码对这些变量的访问权限。

执行`var a = 2 `代码的过程分析：
编译器首先会将这段程序分解成**词法单元**，然后解析成**树结构**，编译器**生成代码**

编译器实际处理：
1. 遇到`var a`，编译器会询问**作用域**是否已存在该变量，如果是，忽略该声明，不是会要求作用域在当前的作用域的集合中声明一个新的变量，并命名为a。
2. 接下来编译器为引擎生成运行时所需的代码，这些代码用来处理`a = 2`这个赋值操作。
3. 引擎在当前作用域查找该变量，找不到会往上找，顶层还是没有就会报错。

## 总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量，然后在运行时引擎会在作用域中查找该变量，如果能够找到就赋值，找不到就会报错。

## 术语：
LHS查询：查询赋值操作的目标，我的理解是变量，键
RHS查询：查询赋值操作的源值，我的理解是值

```js
function foo(a) {
  console.log(a)
}
foo(2)
```
分析上面代码：
1. 首先执行`foo(2)`，查找foo的值，即对foo进行RHS查询
2. 对a进行LHS查询，找到foo的形参a，将2赋值给a
3. `console.log(a)`会对a进行RHS查询，找到值2
4. 对console对象进行RHS查询，找到log方法

```js
function foo(a){  //找a，进行LHS，找到形参a，给a赋值2
  var b = a;  //找b，进行LHS，给b赋值a，对a进行RHS找到2
  return a + b  //找a的值，进行RHS找到2，找b的值进行RHS找到2
}  
var c = foo(2) //找c，进行LHS，赋值foo，foo(2)进行RHS
```

# 嵌套作用域
遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就会去找上一级，直到全局作用域。

# 词法作用域：无论函数在哪里被调用，它的词法作用域都只由函数被声明时所处的位置决定。

注：JavaScript中有两个机制可以欺骗词法作用域： eval（）和with。尽量避免使用，因为这样会使引擎无法再编译时对作用域查找进行优化，导致代码运行变慢。

## 函数作用域和块作用域

函数作用域：属于这个函数的全部变量都可以在整个函数的范围内使用及复用（嵌套的作用域中也可以使用）。实际就是讲变量私有化了。

## 提升
`var a = 2`，这段代码，编译器会分成两部分： `var a` 和 `a = 2`，第一个定义是在**编译阶段**进行的，第二个赋值是留在原地等待**代码执行阶段**

### 函数声明会被提升，但是函数表达式不会被提升。
### 函数声明和变量声明都会被提升，但函数优先，重复的**var声明**会被忽略，但是出现在**后面的函数声明**还是可以覆盖前面的。

# 作用域闭包

本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包!


