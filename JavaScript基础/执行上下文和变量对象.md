# 执行代码
JavaScript引擎并非一行一行的分析和执行程序，而是一段一段的分析执行。

可执行代码分为三种：
全局代码

函数代码

eval代码

JavaScript创建了执行上下文栈来管理执行上下文，模拟上下文栈的行为，定义一个数组：
ECStack = []

当js执行代码时，最先遇到的肯定是全局代码，所以初始化的时候首先就会执行上下文栈压入一个全局执行上下文，用globalContext表示，并且只有当整个应用程序结束的时候，ECStach才会被清空，所以程序结束之前，ECStack底部永远有个globalContext。

当**执行一个函数的时候，就会创建一个执行上下文**，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从执行上下文栈中弹出。

```js
function fun3() {
    console.log('fun3')
}

function fun2() {
    fun3();
}

function fun1() {
    fun2();
}

fun1();

// 伪代码
// fun1()
ECStack.push(<fun1> functionContext);

// fun1中竟然调用了fun2，还要创建fun2的执行上下文
ECStack.push(<fun2> functionContext);

// 擦，fun2还调用了fun3！
ECStack.push(<fun3> functionContext);

// fun3执行完毕
ECStack.pop();

// fun2执行完毕
ECStack.pop();

// fun1执行完毕
ECStack.pop();

// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext
```

# 执行上下文的三个重要属性
1.变量对象

2.作用域链

3.this

# 变量对象
变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

## 执行上下文生命周期
1.创建阶段
执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向
2.代码执行阶段
创建完成之后，就开始执行，这个时候会完成变量赋值，函数引用，以及执行其他代码。

## 进入执行上下文
当进入执行上下文时，还没有执行代码，
变量对象包括：
  1.函数的所有形参（如果是函数上下文）
  2.函数声明
  3.变量声明

全局上下文的变量对象初始化是全局对象

函数上下文的变量对象初始化只包括Arguments对象

在进入执行上下文时会给变量对象添加形参，函数声明，变量声明等初始的属性值

在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性